// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Relay.Value;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Subsystem;
import frc.robot.commands.RunTurretManual;
import frc.robot.commands.RunTurretVision;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Turret implements Subsystem {
    private static final double H_MIN_ENCODER_TICKS = -482070.0;  // used to stop turret from rotating past ends
    private static final double H_MAX_ENCODER_TICKS = 484191.0;
    private static final double H_TICKS_PER_DEGREES = 483000 ;
    private static final double H_DEGREES_PER_TICK = 1 / H_TICKS_PER_DEGREES ;
    private static final double H_MIN_DEGREES = H_MIN_ENCODER_TICKS * H_DEGREES_PER_TICK;
    private static final double H_MAX_DEGREES = H_MAX_ENCODER_TICKS * H_DEGREES_PER_TICK;
    private static final double H_TOLERANCE = 0.5;
    private static final double H_TOLERANCE_VISION = 1;

    //Constants aquired from CAD team used for trig calculations (millimeters):
    public static final double TURRET_SIDE_A = 244.475;
    public static final double TURRET_SIDE_B = 369.4176;
    private final double V_MIN_ANGLE = 20.0; //34.4;
    private final double V_MAX_ANGLE = 57.4;
    private final double V_TOLERANCE = 0.01;
    private double horizontalSetpoint = 0;

    private static final int TIMEOUT_MS = 10;

    private double actuatorDistance;

    private final WPI_TalonSRX turretMotor;
    private final Servo elevationServo;
    private final Relay visionLights;

    public Turret() {    
        turretMotor = new WPI_TalonSRX(7);
        elevationServo = new Servo(0);
        visionLights = new Relay(0);

        turretMotor.set(ControlMode.PercentOutput, 0);
        turretMotor.setSelectedSensorPosition(0);
        turretMotor.setNeutralMode(NeutralMode.Brake);

        setDefaultCommand(new RunTurretVision(this, 0.8));
        SmartDashboard.putString("Vision Status", "disabled");  //Sam: should be "Enabled"
    }

    @Override
    public void periodic() { 
        double d = elevationServo.get() * 140 + 218;
        double a = TURRET_SIDE_A;
        double b = TURRET_SIDE_B;
        double angle = Math.toDegrees(Math.acos((d*d - a*a - b*b)/(-2*a*b)));
        SmartDashboard.putNumber("Turret Elevation", angle);
        SmartDashboard.putNumber("Turret Rotation", getCurrentHorizontalAngle());
        checkHorizontalLimitSwitches();
    }
    
    public void enableVision() {
        visionLights.set(Value.kForward);
    }

    public void disableVision() {
        visionLights.set(Value.kReverse);
    }

    private double calcActuatorDistance(final double angle) {
        // Running law of cosines on the turret
        double d = Math.sqrt(Math.pow(Turret.TURRET_SIDE_A, 2) + Math.pow(Turret.TURRET_SIDE_B, 2) - 2 * Turret.TURRET_SIDE_A * Turret.TURRET_SIDE_B * Math.cos(Math.toRadians(94.4 - angle)));
    
        // This line subtracts the length of the actuator while not extended
        d -= 218;  // 218 is what the actuator blueprints says is the "Closed Length (hole to hole)"
        // This line changes the normalization from 0-140 to 0-1
        d /= 140;  // 140 is what the actuator blueprints says is the max the actuator can extend from the base
        return d;
    }

    public void checkHorizontalLimitSwitches() {
        if (turretMotor.getSensorCollection().isRevLimitSwitchClosed()) {
            turretMotor.setSelectedSensorPosition((int)H_MIN_ENCODER_TICKS, 0, TIMEOUT_MS);
        } else if (turretMotor.getSensorCollection().isFwdLimitSwitchClosed()) {
            turretMotor.setSelectedSensorPosition((int)H_MAX_ENCODER_TICKS, 0, TIMEOUT_MS);
        }
    }

    public boolean atLimitSwitch() {
        return (turretMotor.getSensorCollection().isRevLimitSwitchClosed()
                || turretMotor.getSensorCollection().isFwdLimitSwitchClosed());
    }

    public void gotoHorizontalAngle(double setpoint) {
        horizontalSetpoint = setpoint;
        SmartDashboard.putNumber("Angle Offset", setpoint);
        SmartDashboard.putBoolean("Valid Turret Rotation",
            getCurrentHorizontalAngle() + setpoint < H_MIN_DEGREES
            || getCurrentHorizontalAngle() + setpoint > H_MAX_DEGREES
        );

        if (Math.abs(setpoint) > H_TOLERANCE) {
            double percent = Math.abs(setpoint) / 40;
            percent = Math.max(0.06, Math.min(0.19, percent));   //Sam: can increase 0.19 to make it faster, try doubling 
            if (setpoint < 0) { percent = -percent; }
            turretMotor.set(ControlMode.PercentOutput, percent);
        } else {
            turretMotor.set(ControlMode.PercentOutput, 0);
        }
    }

    public void stopHorizontal() {
        turretMotor.set(ControlMode.PercentOutput, 0);
    }

    public boolean runHorizontalManual(double target) {
        double ticks = turretMotor.getSelectedSensorPosition();
        SmartDashboard.putNumber("Position", ticks);
        if (ticks < 0) {
            ticks /= Math.abs(H_MIN_ENCODER_TICKS);
        } else {
            ticks /= Math.abs(H_MAX_ENCODER_TICKS);
        }
        // SmartDashboard

        double error = target - ticks;
        double speed = 0.2;                                        //Sam: suggest to run proportional to move faster
        SmartDashboard.putNumber("Normal", ticks);
        SmartDashboard.putNumber("Target", target);
        if (Math.abs(error) > 0.03) {
            if (error < 0) { speed = -speed; }
            turretMotor.set(ControlMode.PercentOutput, speed);
            return false;
        } else {
            stopHorizontal();
            return true;
        }
    }

    public void setRawHorizontalPercent(double setpoint) {
        turretMotor.set(ControlMode.PercentOutput, setpoint);
    }

    public double getCurrentHorizontalAngle() {
        return turretMotor.getSelectedSensorPosition();
    }

	public void setRawVertical(double verticalAngle) {
        elevationServo.set(verticalAngle);
	}

	public String getVisionString() {
        if (Math.abs(horizontalSetpoint) < H_TOLERANCE_VISION)
        return "locked";
        else return "homing";
	}
}